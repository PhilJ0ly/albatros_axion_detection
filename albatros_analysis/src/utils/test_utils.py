# Philippe Joly 2025-06-05
import numpy as np
import cupy as cp

import sys
from os import path
sys.path.append(path.expanduser('~'))

from albatros_analysis.src.utils.pfb_cpu_utils import *
from albatros_analysis.src.utils.pfb_gpu_utils import *

"""
Test script to verify that CPU and GPU versions of PFB, IPFB, get_matft produce identical outputs.

The script's outline was generated by Claude 4.0.
"""

import pycufft
from scipy.fft import irfft, rfft
import matplotlib.pyplot as plt

def generate_test_data(nspec, nchan, seed=42):
    np.random.seed(seed)
    
    # Generate complex input data (nspec x nchan)
    dat_real = np.random.randn(nspec, nchan).astype(np.float32)
    dat_imag = np.random.randn(nspec, nchan).astype(np.float32)
    dat_cpu = (dat_real + 1j * dat_imag).astype(np.complex64)
    
    # Convert to GPU array
    dat_gpu = cp.asarray(dat_cpu)
    
    return dat_cpu, dat_gpu

def compare_arrays(cpu_result, gpu_result, test_name, rtol=1e-3, atol=1e-5):
    
    if hasattr(gpu_result, 'get'):  # CuPy array
        gpu_result_cpu = cp.asnumpy(gpu_result)
    else:
        gpu_result_cpu = gpu_result
    
    print(f"\n=== {test_name} ===")
    print(f"CPU output shape: {cpu_result.shape}")
    print(f"GPU output shape: {gpu_result_cpu.shape}")
    print(f"CPU output dtype: {cpu_result.dtype}")
    print(f"GPU output dtype: {gpu_result_cpu.dtype}")
    
    # Check if shapes match
    if cpu_result.shape != gpu_result_cpu.shape:
        print("‚ùå FAIL: Output shapes don't match!")
        return False
    
    # Check if arrays are close
    are_close = np.allclose(cpu_result, gpu_result_cpu, rtol=rtol, atol=atol)
    
    if are_close:
        print("‚úÖ PASS: Outputs match within tolerance")
    else:
        print("‚ùå FAIL: Outputs don't match within tolerance")
    
    # Detailed statistics
    diff = np.abs(cpu_result - gpu_result_cpu)
    rel_diff = diff / (np.abs(cpu_result) + 1e-7)
    
    print(f"Max absolute difference: {np.max(diff):.2e}")
    print(f"Mean absolute difference: {np.mean(diff):.2e}")
    print(f"Max relative difference: {np.max(rel_diff):.2e}")
    print(f"Mean relative difference: {np.mean(rel_diff):.2e}")
    
    # Check for NaNs or Infs
    cpu_nan = np.isnan(cpu_result).any() or np.isinf(cpu_result).any()
    gpu_nan = np.isnan(gpu_result_cpu).any() or np.isinf(gpu_result_cpu).any()
    
    if cpu_nan or gpu_nan:
        print(f"‚ö†Ô∏è  WARNING: NaN/Inf detected - CPU: {cpu_nan}, GPU: {gpu_nan}")
    
    return are_close

def plot_comparison(cpu_result, gpu_result, test_name, save_plots=True):
    """Create comparison plots."""
    if hasattr(gpu_result, 'get'):  # CuPy array
        gpu_result_cpu = cp.asnumpy(gpu_result)
    else:
        gpu_result_cpu = gpu_result
    
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))
    fig.suptitle(f'Comparison: {test_name}')
    
    # Handle different array shapes
    if len(cpu_result.shape) == 2:
        # 2D array (like IPFB output)
        n_plot = min(5, cpu_result.shape[0])
        
        axes[0, 0].plot(cpu_result[:n_plot].T.real)
        axes[0, 0].set_title('CPU Result (first 5 rows)')
        
        axes[0, 1].plot(gpu_result_cpu[:n_plot].T.real)
        axes[0, 1].set_title('GPU Result (first 5 rows)')
        
        diff = cpu_result - gpu_result_cpu
        axes[1, 0].plot(diff[:n_plot].T.real)
        axes[1, 0].set_title('Difference (CPU - GPU)')
        
    else:
        # 1D array or other shapes
        axes[0, 0].plot(cpu_result.real if np.iscomplexobj(cpu_result) else cpu_result)
        axes[0, 0].set_title('CPU Result')
        
        axes[0, 1].plot(gpu_result_cpu.real if np.iscomplexobj(gpu_result_cpu) else gpu_result_cpu)
        axes[0, 1].set_title('GPU Result')
        
        diff = cpu_result - gpu_result_cpu
        axes[1, 0].plot(diff.real if np.iscomplexobj(diff) else diff)
        axes[1, 0].set_title('Difference (CPU - GPU)')
    
    # Difference histogram
    diff = cpu_result - gpu_result_cpu
    diff_flat = diff.flatten()
    if np.iscomplexobj(diff_flat):
        diff_flat = np.abs(diff_flat)
    
    axes[1, 1].hist(diff_flat, bins=50, alpha=0.7)
    axes[1, 1].set_title('Difference Distribution')
    axes[1, 1].set_xlabel('|Difference|')
    axes[1, 1].set_ylabel('Count')
    if np.max(diff_flat) > 0:
        axes[1, 1].set_yscale('log')
    
    plt.tight_layout()
    
    if save_plots:
        filename = f'comparison_{test_name.lower().replace(" ", "_").replace("/", "_")}.png'
        plt.savefig(filename, dpi=150, bbox_inches='tight')
        print(f"Plot saved as: {filename}")
    
    plt.show()

def test_matft_functions(test_cases):
    print("\n" + "="*60)
    print("üîß TESTING MATFT GENERATION FUNCTIONS")
    print("="*60)
    
    
    all_passed = True
    matft_results = []
    
    for i, test_case in enumerate(test_cases):
        print(f"\n--- Test {i+1}: {test_case['name']} ---")
        
        try:
            print("Generating CPU matft...")
            matft_cpu = get_matft_cpu(
                nslice=test_case["nslice"]
            )
            
            print("\nGenerating GPU matft...")
            matft_gpu = get_matft(
                nslice=test_case["nslice"]
            )
            
            passed = compare_arrays(matft_cpu, matft_gpu, f"matft {test_case['name']}")
            all_passed = all_passed and passed
            
            # Store results for IPFB testing
            matft_results.append({
                'cpu': matft_cpu,
                'gpu': matft_gpu,
                'nslice': test_case["nslice"],
                "osamp" : test_case["osamp"],
                "pfb_mult" : test_case["pfb_mult"],
                'name': test_case["name"]
            })
            
            # if i == 0:
            #     plot_comparison(matft_cpu, matft_gpu, f"matft {test_case['name']}")
                
        except Exception as e:
            print(f"‚ùå ERROR in matft {test_case['name']}: {str(e)}")
            all_passed = False
    
    return all_passed, matft_results

def test_ipfb(matft_results):
    print("\n" + "="*60)
    print("üßÆ TESTING IPFB ")
    print("="*60)
    
    all_passed = True
    ipfb_results = []
    thresh_values = [0.45]

    
    for matft_result in matft_results:
        matft_cpu = matft_result['cpu']
        matft_gpu = matft_result['gpu']
        nslice = matft_result['nslice']
        name = matft_result['name']
        
        nspec = nslice 
        dat_cpu, dat_gpu = generate_test_data(nspec, nchan=2049, seed=41)
        
        for thresh in thresh_values:
            test_name = f"IPFB {name} (thresh={thresh})"
            print(f"\n--- {test_name} ---")
            
            try:             
                print(f"Input data shape: {dat_cpu.shape}")
                print(f"Matft shape: {matft_cpu.shape}")
                
                # Run CPU version
                print("Running CPU IPFB...")
                cpu_result = cpu_ipfb(dat_cpu, matft_cpu, thresh=thresh)
                
                # Run GPU version
                print("Running GPU IPFB...")
                gpu_result = cupy_ipfb(dat_gpu, matft_gpu, thresh=thresh)

                # Keep results for PFB test
                ipfb_results.append({
                    'cpu': cpu_result,
                    'gpu': gpu_result,
                    "osamp" : matft_result["osamp"],
                    "pfb_mult" : matft_result["pfb_mult"],
                    'name': name,
                    'thresh': thresh
                })
            
                
                # Compare results
                passed = compare_arrays(cpu_result, gpu_result, test_name)
                all_passed = all_passed and passed
                
                # Plot comparison for first case
                # if name == matft_results[0]['name']:
                #     plot_comparison(cpu_result, gpu_result, test_name)
                
            except Exception as e:
                print(f"‚ùå ERROR in {test_name}: {str(e)}")
                import traceback
                traceback.print_exc()
                all_passed = False
    
    return all_passed, ipfb_results

def test_pfb(ipfb_results):
    print("\n" + "="*60)
    print("üßÆ TESTING PFB ")
    print("="*60)

    cutsize = 16
    all_passed = True

    for result in ipfb_results:
        cpu_dat = result["cpu"]
        # gpu_dat = result["gpu"]
        gpu_dat = cp.asarray(result["cpu"])
    
        pfb_mult = result["pfb_mult"]
        osamp = result["osamp"]
        name = result["name"]
        thresh = result["thresh"]
    
        test_name = f"PFB {name} (thresh={thresh})"
        print(f"\n--- {test_name} ---")


        nchan = 2048*osamp+1
        dwin = sinc_hamming(ntap=4,lblock=2048*2*osamp)
        cut = int(osamp*pfb_mult/cutsize)


        try:
            print(f"Input data shape: {cpu_dat[cut:-cut].shape}")

            print("Running CPU PFB...")
            cpu_win_big = np.asarray(dwin, dtype='float32', order='C').reshape(4,2*(2048*osamp+1-1))
            print("win input shape", cpu_win_big.shape)
            cpu_result = cpu_pfb(cpu_dat[cut:-cut],cpu_win_big, nchan=2048*osamp+1, ntap=4 )

            print("Running GPU PFB...")
            cupy_win_big=cp.asarray(dwin,dtype='float32',order='c').reshape(4,2*(2048*osamp+1-1))
            gpu_result = cupy_pfb(gpu_dat[cut:-cut],cupy_win_big, nchan=2048*osamp+1, ntap=4 )

            passed = compare_arrays(cpu_result, gpu_result, test_name)
            all_passed = all_passed and passed
            
            # Plot comparison for first case
            # if name == ipfb_results[0]['name']:
            #     plot_comparison(cpu_result, gpu_result, test_name)

        except Exception as e:
                print(f"‚ùå ERROR in {test_name}: {str(e)}")
                import traceback
                traceback.print_exc()
                all_passed = False
        
    return all_passed
        
def main():
    test_cases = [
        {"osamp": 64, "pfb_mult": 256},
        {"osamp": 512, "pfb_mult": 128},
        {"osamp": 2**12, "pfb_mult": 32}
        # {"osamp": 2**16, "pfb_mult": 8} too much memory for GPU
    ]

    for tester in test_cases:
        tester["name"] = f"Osamp ({tester['osamp']}) pfb_mult ({tester['pfb_mult']})"
        tester["nslice"] = tester["osamp"]*tester["pfb_mult"]

    print("üß™ COMPREHENSIVE PFB/IPFB AND MATFT TESTING")
    print("="*60)
    
    matft_passed, matft_results = test_matft_functions(test_cases)
    
    ipfb_passed, ipfb_results = test_ipfb(matft_results)

    pfb_passed  = test_pfb(ipfb_results)
    
    # Final summary
    print("\n" + "="*60)
    print("üìä FINAL RESULTS")
    print("="*60)
    
    if matft_passed:
        print("‚úÖ MATFT generation functions: PASSED")
    else:
        print("‚ùå MATFT generation functions: FAILED")
    
    if ipfb_passed:
        print("‚úÖ IPFB functions: PASSED")
    else:
        print("‚ùå IPFB functions: FAILED")

    if pfb_passed:
        print("‚úÖ PFB functions: PASSED")
    else:
        print("‚ùå PFB functions: FAILED")
    
    if matft_passed and ipfb_passed and pfb_passed:
        print("\nüéâ ALL TESTS PASSED! Both CPU and GPU implementations are equivalent.")
    else:
        print("\n‚ùå SOME TESTS FAILED! Check the output above for details.")
    
    print("\nüìà Check generated plots for visual verification.")

if __name__ == "__main__":
    main()